%\VignetteIndexEntry{EBSeq Vignette}

\documentclass{article}
\usepackage{fullpage}
\usepackage{graphicx, graphics, epsfig,setspace,amsmath, amsthm}
\usepackage{hyperref}
\usepackage{natbib}
%\usepackage{listings}
\usepackage{moreverb}
\usepackage{Sweave}
\begin{document}
\input{EBSeq_Vignette-concordance}
\title{EBSeq: An R package for differential expression analysis using RNA-seq data}
\author{Ning Leng, John Dawson, Xiuyu Ma, Michael A. Newton, and Christina Kendziorski}
\maketitle
\tableofcontents
\setcounter{tocdepth}{2}

\section{Introduction}
EBSeq may be used to identify differentially expressed (DE)
genes and isoforms in an RNA-Seq experiment. As detailed in
Leng {\it et al.}, 2013 \cite{Leng13}, 
EBSeq is an empirical Bayesian approach that models a number of features
observed in RNA-seq data. Importantly, for isoform level inference,
EBSeq directly accommodates isoform expression estimation uncertainty by
modeling the differential variability observed in distinct groups of isoforms.
Consider Figure 1, where we have plotted variance against mean
for all isoforms using RNA-Seq expression data from Leng {\it et al.}, 2013 \cite{Leng13}.
Also shown is the fit within three sub-groups of isoforms defined
by the number of constituent isoforms of the parent gene.
An isoform of gene $g$ is assigned to the $I_g=k$ group, where $k=1,2,3$,
if the total number of isoforms from gene $g$ is $k$ (the $I_g=3$ group contains
all isoforms from genes having 3 or more isoforms).
As shown in Figure 1, there is decreased variability in the $I_g=1$ group,
but increased variability in the others, due to the relative increase in
uncertainty inherent in estimating isoform expression when multiple isoforms of a given gene are
present.  If this structure is not accommodated, there is reduced power for
identifying isoforms in the $I_g=1$ group (since the true variances in that group are
lower, on average, than that derived from the full collection of isoforms) as well as increased
false discoveries in the $I_g=2$ and $I_g=3$ groups (since the true variances are higher, on average,
than those derived from the full collection). EBSeq directly models differential variability
as a function of $I_g$ providing a powerful approach for isoform level inference. As shown in Leng {\it et al.}, 2013
\cite{Leng13}, the model is also useful for identifying DE genes.
One bottleneck of the model is that the number of DE patterns is growing factorially with the number of conditions($K$) for comparison (Bell number), which makes the computation infeasible for big $K$. In EBSeq.2, we provide a pruning scheme by removing those unlikely patterns and greatly reducing the size of patterns. We utilize a one-step EM and rewrite the code in C++ for further efficiency.
We will briefly detail the model in Section \ref{sec:model} and then describe
the flow of analysis in Section \ref{sec:quickstart} for both isoform and gene-level inference.


\begin{figure}[t]
\centering
\includegraphics[width=0.6\textwidth]{PlotExample.png}
\label{fig:GouldNg}
\caption{Empirical variance vs. mean for
each isoform profiled in the ESCs vs iPSCs experiment detailed in
the Case Study section of Leng {\it et al.}, 2013 \cite{Leng13}.
A spline fit to all isoforms is shown in red with splines fit within the $I_g=1$, $I_g=2$, and $I_g=3$ isoform groups
shown in yellow, pink, and green, respectively.}
\end{figure}


\section{Citing this software}
\label{sec:cite}
Please cite the following article when reporting results from the software.

\noindent Leng, N., J.A. Dawson, J.A. Thomson, V. Ruotti, A.I. Rissman, 
B.M.G. Smits, J.D. Haag, M.N. Gould, R.M. Stewart, and C. Kendziorski. 
EBSeq: An empirical Bayes hierarchical model for inference in RNA-seq
experiments, {\it Bioinformatics}, 2013.

\section{The Model}
\label{sec:model}
\subsection{Two conditions}
\label{sec:twocondmodel}
We let $X_{g_i}^{C1} = X_{g_i,1} ,X_{g_i,2}, ...,X_{g_i,S_1}$ denote data from condition 1
and $ X_{g_i}^{C2} = X_{g_i,(S_1+1)},X_{g_i,(S_1+2)},...,X_{g_i,S}$ data from condition 2.
We assume that counts within condition $C$ are distributed as Negative Binomial: 
$X_{g_i,s}^C|r_{g_i,s}, q_{g_i}^C \sim NB(r_{g_i,s}, q_{g_i}^C)$ where
\begin{equation}
P(X_{g_i,s}|r_{g_i,s},q_{g_i}^C) = {X_{g_i,s}+r_{g_i,s}-1\choose X_{g_i,s}}(1-q_{g_i}^C)^{X_{g_i,s}}(q_{g_i}^C)^{r_{g_i,s}}\label{eq:01}
\end{equation}

\noindent and $\mu_{g_i,s}^C=r_{g_i,s} (1-q_{g_i}^C)/q_{g_i}^C$;
$(\sigma_{g_i,s}^C)^2=r_{g_i,s} (1-q_{g_i}^C)/(q_{g_i}^C)^2.$

\medskip

We assume a prior distribution on $q_{g_i}^C$: $q_{g_i}^C|\alpha, \beta^{I_g} \sim Beta(\alpha, \beta^{I_g})$.
The hyperparameter $\alpha$ is shared by all the isoforms and $\beta^{I_g}$ is $I_g$ specific (note this is an index, not a power).
We further assume that $r_{g_i,s}=r_{g_i,0} l_s$, where $r_{g_i,0}$ is an isoform specific 
parameter common across conditions and $r_{g_i,s}$ depends on it through the sample-specific normalization factor $l_s$.
Of interest in this two group comparison is distinguishing between two cases, or what we will refer to subsequently as
two patterns of expression, namely equivalent expression (EE) and differential expression (DE):
\begin{center}
$H_0$ (EE) : $q_{g_i}^{C1}=q_{g_i}^{C2}$  vs  $H_1$ (DE) : $q_{g_i}^{C1} \neq q_{g_i}^{C2}$.
\end{center}
Under the null hypothesis (EE), the data $X_{g_i}^{C1,C2} = X_{g_i}^{C1}, X_{g_i}^{C2}$ arises 
from the prior predictive distribution $f_0^{I_g}(X_{g_i}^{C1,C2})$:
%\tiny
\begin{equation}
f_0^{I_g}(X_{g_i}^{C1,C2})=\Bigg[\prod_{s=1}^S {X_{g_i,s}+r_{g_i,s}-1\choose X_{g_i,s}}\Bigg]
\frac{Beta(\alpha+\sum_{s=1}^S r_{g_i,s}, \beta^{I_g}+\sum_{s=1}^SX_{g_i,s} )}{Beta(\alpha, \beta^{I_g})}\label{eq:05}
\end{equation}
%\normalsize

Alternatively (in a DE scenario), $X_{g_i}^{C1,C2}$ follows the prior predictive distribution $f_1^{I_g}(X_{g_i}^{C1,C2})$:
\begin{equation}
f_1^{I_g}(X_{g_i}^{C1,C2})=f_0^{I_g}(X_{g_i}^{C1})f_0^{I_g}(X_{g_i}^{C2}) \label{eq:06}
\end{equation}

Let the latent variable $Z_{g_i}$ be defined so that $Z_{g_i} = 1$ indicates that 
isoform $g_i$ is DE and $Z_{g_i} =  0$ indicates isoform $g_i$ is EE, and
$Z_{g_i} \sim Bernoulli(p)$.
Then, the marginal distribution of $X_{g_i}^{C1,C2}$ and $Z_{g_i}$ is:
\begin{equation}
(1-p)f_0^{I_g}(X_{g_i}^{C1,C2}) + pf_1^{I_g}(X_{g_i}^{C1,C2})\label{eq:07}
\end{equation}

\noindent The posterior probability of being DE at isoform $g_i$ is obtained by Bayes' rule:
\begin{equation}
\frac{pf_1^{I_g}(X_{g_i}^{C1,C2})}{(1-p)f_0^{I_g}(X_{g_i}^{C1,C2}) + pf_1^{I_g}(X_{g_i}^{C1,C2})}\label{eq:08}
\end{equation}

%\newpage
\subsection{More than two conditions}
\label{sec:multicondmodel}
EBSeq naturally accommodates multiple condition comparisons.
For example, in a study with 3 conditions, there are K=5 possible expression patterns (P1,...,P5), or ways in which
latent levels of expression may vary across conditions:
\begin{align}
\textrm {P1:}& \hspace{0.05in} q_{g_i}^{C1} = q_{g_i}^{C2}=q_{g_i}^{C3} \nonumber \\
\textrm {P2:}& \hspace{0.05in} q_{g_i}^{C1} = q_{g_i}^{C2} \neq q_{g_i}^{C3} \nonumber \\
\textrm {P3:}& \hspace{0.05in} q_{g_i}^{C1} = q_{g_i}^{C3} \neq q_{g_i}^{C2} \nonumber \\
\textrm {P4:}& \hspace{0.05in} q_{g_i}^{C1} \neq q_{g_i}^{C2} = q_{g_i}^{C3} \nonumber \\
\textrm {P5:}& \hspace{0.05in} q_{g_i}^{C1} \neq q_{g_i}^{C2} \neq
q_{g_i}^{C3} \textrm{ and } q_{g_i}^{C1} \neq q_{g_i}^{C3} \nonumber
\end{align}

\noindent The prior predictive distributions for these are given, respectively, by:

\begin{align}
g_1^{I_g}(X_{g_i}^{C1,C2,C3}) &= f_0^{I_g}(X_{g_i}^{C1,C2,C3}) \nonumber \\
g_2^{I_g}(X_{g_i}^{C1,C2,C3}) &= f_0^{I_g}(X_{g_i}^{C1,C2})f_0^{I_g}(X_{g_i}^{C3}) \nonumber \\
g_3^{I_g}(X_{g_i}^{C1,C2,C3}) &= f_0^{I_g}(X_{g_i}^{C1,C3})f_0^{I_g}(X_{g_i}^{C2}) \nonumber \\
g_4^{I_g}(X_{g_i}^{C1,C2,C3}) &= f_0^{I_g}(X_{g_i}^{C1})f_0^{I_g}(X_{g_i}^{C2,C3}) \nonumber \\
g_5^{I_g}(X_{g_i}^{C1,C2,C3}) &= f_0^{I_g}(X_{g_i}^{C1})f_0^{I_g}(X_{g_i}^{C2})f_0^{I_g}(X_{g_i}^{C3}) \nonumber
\end{align}

\noindent where $f_0^{I_g}$ is the same as in equation \ref{eq:05}. Then the marginal distribution in 
equation \ref{eq:07} becomes:

\begin{equation}
\sum_{k=1}^5 p_k g_k^{I_g}(X_{g_i}^{C1,C2,C3}) \label{eq:11}
\end{equation}
\noindent where $\sum_{k=1}^5 p_k = 1$. Thus, the posterior probability of
isoform $g_i$ coming from pattern $K$ is readily obtained by:

\begin{equation}
\frac{p_K g_K^{I_g}(X_{g_i}^{C1,C2,C3})}{\sum_{k=1}^5 p_k g_k^{I_g}(X_{g_i}^{C1,C2,C3})} \label{eq:12}
\end{equation}

\subsection{Getting a false discovery rate (FDR) controlled list of genes or isoforms}
\label{sec:fdrlist}
To obtain a list of DE genes with false discovery rate (FDR) controlled
at $\alpha$ in an experiment comparing two biological conditions, the genes
with posterior probability of being DE (PPDE) greater than 1 - $\alpha$ should be used.
For example, the genes with PPDE>=0.95 make up the list of DE genes with target
FDR controlled at 5\%.  With more than two biological conditions, there are multiple
DE patterns (see Section \ref{sec:multicondmodel}). To obtain a list of genes in a specific DE pattern with target
FDR $\alpha$, a user should
take the genes with posterior probability of being in that pattern greater
than 1 - $\alpha$. Isoform-based lists are obtained in the same way.
\newpage
\section{Quick Start}
\label{sec:quickstart}
Before analysis can proceed, the EBSeq package must be loaded into the working space:
\begin{Schunk}
\begin{Sinput}
> library(EBSeq)
\end{Sinput}
\end{Schunk}
\subsection{Gene level DE analysis (two conditions)}
\label{sec:startgenede}
\subsubsection{Required input}
\label{sec:startgenedeinput}
\begin{flushleft}
{\bf Data}:  The object \verb+Data+ should be a $G-by-S$ matrix containing the expression values for each gene and each sample,
where $G$ is the number of genes and $S$ is the number of samples. These
values should exhibit raw counts, without normalization
across samples. Counts of this nature may be obtained from RSEM \cite{Li11b},
Cufflinks \cite{Trapnell12}, or a similar approach.

\vspace{5 mm}

{\bf Conditions}:  The object \verb+Conditions+ should be a Factor vector of length $S$ that indicates to which condition each sample belongs.
For example, if there are two conditions and three samples in each,
$S=6$ and \verb+Conditions+ may be given by 

\verb+as.factor(c("C1","C1","C1","C2","C2","C2"))+

\end{flushleft} 
\noindent The object \verb+GeneMat+ is a simulated data matrix containing 
1,000 rows of genes and 10 columns of samples. The genes are named 
\verb+Gene_1, Gene_2 ...+
\begin{Schunk}
\begin{Sinput}
> data(GeneMat)
> str(GeneMat)
\end{Sinput}
\begin{Soutput}
 num [1:1000, 1:10] 1879 24 3291 97 485 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:1000] "Gene_1" "Gene_2" "Gene_3" "Gene_4" ...
  ..$ : NULL
\end{Soutput}
\end{Schunk}

\subsubsection{Library size factor}
\label{sec:startgenedesize}
As detailed in Section \ref{sec:model}, EBSeq requires the library size factor $l_s$ for each sample $s$.
Here, $l_s$ may be obtained via the function \verb+MedianNorm+, which reproduces the median normalization approach
in DESeq \citep{Anders10}.
\begin{Schunk}
\begin{Sinput}
> Sizes=MedianNorm(GeneMat)
\end{Sinput}
\end{Schunk}

\noindent If quantile normalization is preferred, $l_s$ may be obtained via the function \verb+QuantileNorm+. 
(e.g. \verb+QuantileNorm(GeneMat,.75)+ for Upper-Quantile Normalization in \cite{Bullard10})

\subsubsection{Running EBSeq on gene expression estimates}
\label{sec:startgenederun}
The function \verb+EBTest+ is used to detect DE genes. 
For gene-level data, we don't need to specify the parameter 
\verb+NgVector+ since there are no differences in $I_g$ structure among the different genes.
Here, we simulated the first five samples to be in condition 1 and the other five in condition 2, so define: 

\verb+Conditions=as.factor(rep(c("C1","C2"),each=5))+

\noindent \verb+sizeFactors+ is used to define the library size factor of each sample. 
It could be obtained by summing up the total number of reads within each sample, 
Median Normalization \citep{Anders10},
scaling normalization \citep{Robinson10}, Upper-Quantile Normalization \cite{Bullard10}, 
or some other such approach.
These in hand, we run the EM algorithm, setting the number 
of iterations to five via \verb+maxround=5+ for demonstration purposes. 
However, we note that in practice, 
additional iterations are usually required. Convergence should always be 
checked (see Section \ref{sec:detailedgenedeconverge} for details).
Please note this may take several minutes:
\begin{Schunk}
\begin{Sinput}
> #EBOut=EBTest(Data=GeneMat, 
> #Conditions=as.factor(rep(c("C1","C2"),each=5)),sizeFactors=Sizes, maxround=5)
> EBOut = EBTest(Data=GeneMat, Conditions=as.factor(rep(c("C1","C2"),each=5)),
+        sizeFactors = Sizes)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 2
Final number of DE patterns = 2
\end{Soutput}
\end{Schunk}
\noindent The list of DE genes and the posterior probabilities of being DE are obtained as follows
\begin{Schunk}
\begin{Sinput}
> EBDERes=GetDEResults(EBOut, FDR=0.05)
> str(EBDERes$DEfound)
\end{Sinput}
\begin{Soutput}
 chr [1:94] "Gene_1" "Gene_2" "Gene_3" "Gene_4" "Gene_5" "Gene_6" "Gene_7" ...
\end{Soutput}
\begin{Sinput}
> head(EBDERes$PPMat)
\end{Sinput}
\begin{Soutput}
                PPEE PPDE
Gene_1  0.000000e+00    1
Gene_2  6.831008e-47    1
Gene_3 1.070213e-218    1
Gene_4  2.085332e-33    1
Gene_5 1.907801e-229    1
Gene_6  1.170782e-09    1
\end{Soutput}
\begin{Sinput}
> str(EBDERes$Status)
\end{Sinput}
\begin{Soutput}
 Named chr [1:1000] "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" ...
 - attr(*, "names")= chr [1:1000] "Gene_1" "Gene_2" "Gene_3" "Gene_4" ...
\end{Soutput}
\end{Schunk}
\noindent \verb+EBDERes$DEfound+ is a list of genes identified with 5\% FDR. EBSeq found
95 genes. The matrix \verb+EBDERes$PPMat+ contains two columns \verb+PPEE+ and \verb+PPDE+, 
corresponding to the posterior probabilities of being EE or DE for each gene. 
\verb+EBDERes$Status+ contains each gene's status called by EBSeq. 

\noindent Note the \verb+GetDEResults()+ was incorporated in EBSeq since version 1.7.1. 
By using the default settings, the number of genes identified in any given analysis may 
differ slightly from the previous version. The updated algorithm is more robust to outliers
and transcripts with low variance. To obtain results that are comparable
to results from earlier versions of EBSeq ($\le$ 1.7.0), a user may set
\verb+Method="classic"+ in \verb+GetDEResults()+ function, or use the \verb+GetPPMat()+ function.


\subsection{Isoform level DE analysis (two conditions)}
\label{sec:startisode}
\subsubsection{Required inputs}
\label{sec:startisodeinput}

\begin{flushleft}
{\bf Data}:   The object \verb+Data+ should be a $I-by-S$ matrix containing the expression values for each isoform and each sample,
where $I$ is the number of isoforms and $S$ is the number of sample. As in the gene-level analysis, these values should exhibit raw data, without normalization
across samples.

\vspace{5 mm}

{\bf Conditions}:  The object \verb+Conditions+ should be a vector with length $S$ to indicate the condition of each sample.

\vspace{5 mm}

{\bf IsoformNames}:   The object \verb+IsoformNames+ should be a vector with length $I$ to indicate the isoform names.

\vspace{5 mm}

{\bf IsosGeneNames}:  The object \verb+IsosGeneNames+ should be a vector with length $I$ to indicate the gene name of each isoform. 
(in the same order as \verb+IsoformNames+.)
\end{flushleft}

\noindent \verb+IsoList+ contains 1,200 simulated isoforms. 
In which \verb+IsoList$IsoMat+ is a data matrix containing
1,200 rows of isoforms and 10 columns of samples; 
\verb+IsoList$IsoNames+ contains the isoform names; 
\verb+IsoList$IsosGeneNames+ contains the names of the genes the isoforms belong to.

\begin{Schunk}
\begin{Sinput}
> data(IsoList)
> str(IsoList)
\end{Sinput}
\begin{Soutput}
List of 3
 $ IsoMat       : num [1:1200, 1:10] 176 789 1300 474 1061 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
  .. ..$ : NULL
 $ IsoNames     : chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
 $ IsosGeneNames: chr [1:1200] "Gene_1" "Gene_2" "Gene_3" "Gene_4" ...
\end{Soutput}
\begin{Sinput}
> IsoMat=IsoList$IsoMat
> str(IsoMat)
\end{Sinput}
\begin{Soutput}
 num [1:1200, 1:10] 176 789 1300 474 1061 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
  ..$ : NULL
\end{Soutput}
\begin{Sinput}
> IsoNames=IsoList$IsoNames
> IsosGeneNames=IsoList$IsosGeneNames
\end{Sinput}
\end{Schunk}

\subsubsection{Library size factor}
\label{sec:startisodesize}
Similar to the gene-level analysis presented above, we may obtain the isoform-level 
library size factors via \verb+MedianNorm+:
\begin{Schunk}
\begin{Sinput}
> IsoSizes=MedianNorm(IsoMat)
\end{Sinput}
\end{Schunk}

\subsubsection{The $I_g$ vector}
\label{sec:startisodeNg}

While working on isoform level data, EBSeq fits different prior 
parameters for different uncertainty groups (defined as $I_g$ groups).
The default setting to define the uncertainty groups consists of using 
the number of isoforms the host gene contains ($N_g$) for each isoform. 
The default settings will provide three uncertainty groups: 

$I_g=1$ group: Isoforms with $N_g=1$;

$I_g=2$ group: Isoforms with $N_g=2$;

$I_g=3$ group: Isoforms with $N_g \geq 3$.

The $N_g$ and $I_g$ group assignment can be obtained using the function \verb+GetNg+. 
The required inputs of \verb+GetNg+ are the isoform names (\verb+IsoformNames+) and 
their corresponding gene names (\verb+IsosGeneNames+).
\begin{Schunk}
\begin{Sinput}
> NgList=GetNg(IsoNames, IsosGeneNames)
> IsoNgTrun=NgList$IsoformNgTrun
> IsoNgTrun[c(1:3,201:203,601:603)]
\end{Sinput}
\begin{Soutput}
Iso_1_1 Iso_1_2 Iso_1_3 Iso_2_1 Iso_2_2 Iso_2_3 Iso_3_1 Iso_3_2 Iso_3_3 
      1       1       1       2       2       2       3       3       3 
\end{Soutput}
\end{Schunk}
More details could be found in Section \ref{sec:detailedisode}.

\subsubsection{Running EBSeq on isoform expression estimates}
\label{sec:startisoderun}
The \verb+EBTest+ function is also used to run EBSeq for two condition comparisons 
on isoform-level data. 
Below we use 5 iterations to demonstrate.  However, as
in the gene level analysis, we advise that additional iterations will likely be 
required in practice (see Section \ref{sec:detailedisodeconverge} for details). 

\begin{Schunk}
\begin{Sinput}
> IsoEBOut = EBTest(Data=IsoMat, NgVector=IsoNgTrun, 
+ Conditions=as.factor(rep(c("C1","C2"),each=5)),sizeFactors=IsoSizes)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 2
Final number of DE patterns = 2
\end{Soutput}
\begin{Sinput}
> IsoEBDERes=GetDEResults(IsoEBOut, FDR=0.05)
> str(IsoEBDERes$DEfound)
\end{Sinput}
\begin{Soutput}
 chr [1:104] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" "Iso_1_5" "Iso_1_6" ...
\end{Soutput}
\begin{Sinput}
> head(IsoEBDERes$PPMat)
\end{Sinput}
\begin{Soutput}
                 PPEE PPDE
Iso_1_1  1.179612e-18    1
Iso_1_2  2.440508e-83    1
Iso_1_3  0.000000e+00    1
Iso_1_4 5.585848e-206    1
Iso_1_5  3.898363e-71    1
Iso_1_6  8.466569e-55    1
\end{Soutput}
\begin{Sinput}
> str(IsoEBDERes$Status)
\end{Sinput}
\begin{Soutput}
 Named chr [1:1200] "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" ...
 - attr(*, "names")= chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
\end{Soutput}
\end{Schunk}
\noindent We see that EBSeq found 104 DE isoforms at the target FDR of 0.05. 

\noindent Note the \verb+GetDEResults()+ was incorporated in EBSeq since version 1.7.1.
By using the default settings, the number of transcripts identified in any given analysis may 
differ slightly from the previous version. The updated algorithm is more robust to outliers
and transcripts with low variance. To obtain results that are comparable
to results from earlier versions of EBSeq ($\le$ 1.7.0), a user may set
\verb+Method="classic"+ in \verb+GetDEResults()+ function, or use the \verb+GetPPMat()+ function.






\subsection{Gene level DE analysis (more than two conditions)}
\label{sec:startmulticond}
\noindent The object \verb+MultiGeneMat+ is a matrix containing 
500 simulated genes with 6 samples: 
the first two samples are from condition 1; the second and the third sample are 
from condition 2; the last two samples are from condition 3.

\begin{Schunk}
\begin{Sinput}
> data(MultiGeneMat)
> str(MultiGeneMat)
\end{Sinput}
\begin{Soutput}
 num [1:500, 1:6] 411 268 768 1853 878 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:500] "Gene_1" "Gene_3" "Gene_5" "Gene_7" ...
  ..$ : NULL
\end{Soutput}
\end{Schunk}
In analysis where the data are spread over more than two conditions,
the set of possible patterns for each gene is more complicated
than simply EE and DE. As noted in Section \ref{sec:model}, when we have 3 conditions, there are 5 expression
patterns to consider. In the simulated data, we have 6 samples, 2 in each of 3 conditions.
\begin{Schunk}
\begin{Sinput}
> Conditions=c("C1","C1","C2","C2","C3","C3")
\end{Sinput}
\end{Schunk}

\verb+MedianNorm+ or one of its competitors should be used to determine the normalization factors.
Once this is done, the formal test is performed by \verb+EBMultiTest+. 
\begin{Schunk}
\begin{Sinput}
> MultiSize=MedianNorm(MultiGeneMat)
> MultiOut=EBMultiTest(MultiGeneMat,Conditions=Conditions,
+  sizeFactors=MultiSize, uc = 2)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 5
Final number of DE patterns = 5
\end{Soutput}
\end{Schunk}
The function \verb+GetPatterns+ allows the user to get selected patterns. For example:

\begin{Schunk}
\begin{Sinput}
> PosParti=GetPatterns(MultiOut)
> PosParti
\end{Sinput}
\begin{Soutput}
         C1 C2 C3
Pattern1  1  2  3
Pattern2  1  1  2
Pattern3  1  2  2
Pattern4  1  1  1
Pattern5  1  2  1
\end{Soutput}
\end{Schunk}

\noindent where the first row means all three conditions have distinct latent mean expression level; 
the second row means C1 and C2 have the same latent mean expression level but that of C3 is different; 
and the last row corresponds to the case where C1 and C3 have the same latent mean expression level but that of C2 is different.
\noindent The posterior probability of being in each pattern for every gene is obtained by using the 
function \verb+GetMultiPP+:
\begin{Schunk}
\begin{Sinput}
> MultiPP=GetMultiPP(MultiOut)
> names(MultiPP)
\end{Sinput}
\begin{Soutput}
[1] "PP"       "MAP"      "Patterns"
\end{Soutput}
\begin{Sinput}
> MultiPP$PP[1:10,]
\end{Sinput}
\begin{Soutput}
           pattern1  pattern2      pattern3      pattern4      pattern5
Gene_1  0.342709563 0.6572904  6.870408e-72  3.015440e-93  2.864790e-55
Gene_3  0.006595105 0.9934049 5.340316e-109 3.433672e-163 2.922145e-116
Gene_5  0.042482476 0.9575175  5.309949e-20  7.837887e-26  1.140460e-18
Gene_7  0.157609361 0.8423906  0.000000e+00  0.000000e+00 2.905691e-294
Gene_9  0.040619174 0.9593808  2.441999e-15  9.088562e-16  9.343836e-16
Gene_11 0.053841782 0.9461582  2.607784e-12  2.955394e-11  4.570651e-11
Gene_13 0.106486219 0.8935129  9.194008e-10  6.798796e-08  7.735994e-07
Gene_15 0.027054430 0.9729456  1.079379e-40  5.379139e-47  2.410435e-44
Gene_17 0.181376143 0.8186239 4.590012e-133 7.310837e-184 9.831129e-113
Gene_19 0.048700449 0.9512996  1.080862e-24  2.792245e-37  6.753301e-28
\end{Soutput}
\begin{Sinput}
> MultiPP$MAP[1:10]
\end{Sinput}
\begin{Soutput}
    Gene_1     Gene_3     Gene_5     Gene_7     Gene_9    Gene_11    Gene_13 
"pattern2" "pattern2" "pattern2" "pattern2" "pattern2" "pattern2" "pattern2" 
   Gene_15    Gene_17    Gene_19 
"pattern2" "pattern2" "pattern2" 
\end{Soutput}
\begin{Sinput}
> MultiPP$Patterns
\end{Sinput}
\begin{Soutput}
         C1 C2 C3
Pattern1  1  2  3
Pattern2  1  1  2
Pattern3  1  2  2
Pattern4  1  1  1
Pattern5  1  2  1
\end{Soutput}
\end{Schunk}
\noindent where \verb+MultiPP$PP+ provides the posterior probability of being in each pattern for every gene. 
\verb+MultiPP$MAP+ provides the most likely pattern of each gene based on the posterior 
probabilities. \verb+MultiPP$Patterns+ provides the details of the patterns. 



\subsection{Isoform level DE analysis (more than two conditions)}
\label{sec:startisomulticond}
\noindent Similar to \verb+IsoList+,
the object \verb+IsoMultiList+ is an object containing the isoform expression estimates matrix, the isoform 
names, and the gene names of the isoforms' host genes. 
\verb+IsoMultiList$IsoMultiMat+ contains 300 simulated isoforms with 8 samples. 
The first two samples are from condition 1; the second and the third sample are 
from condition 2; the fifth and sixth sample are from condition 3; 
the last two samples are from condition 4.
Similar to Section \ref{sec:startisode},  the function \verb+MedianNorm+ and \verb+GetNg+ could be used for normalization 
and calculating the $N_g$'s. 
\begin{Schunk}
\begin{Sinput}
> data(IsoMultiList)
> IsoMultiMat=IsoMultiList[[1]]
> IsoNames.Multi=IsoMultiList$IsoNames
> IsosGeneNames.Multi=IsoMultiList$IsosGeneNames
> IsoMultiSize=MedianNorm(IsoMultiMat)
> NgList.Multi=GetNg(IsoNames.Multi, IsosGeneNames.Multi)
> IsoNgTrun.Multi=NgList.Multi$IsoformNgTrun
> Conditions=c("C1","C1","C2","C2","C3","C3","C4","C4")
\end{Sinput}
\end{Schunk}



\noindent
\verb+EBMultiTest+ could be used to perform the test:
\begin{Schunk}
\begin{Sinput}
> IsoMultiOut=EBMultiTest(IsoMultiMat,
+ NgVector=IsoNgTrun.Multi,Conditions=Conditions,
+ sizeFactors=IsoMultiSize, 
+ uc = 2,nequal = 10)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 12
Final number of DE patterns = 12
\end{Soutput}
\end{Schunk}

The function \verb+GetPatterns+ allows the user to get selected patterns. For example:

\begin{Schunk}
\begin{Sinput}
> PosParti.4Cond=GetPatterns(IsoMultiOut)
> PosParti.4Cond
\end{Sinput}
\begin{Soutput}
          C1 C2 C3 C4
Pattern1   1  1  1  2
Pattern2   1  1  2  3
Pattern3   1  2  2  3
Pattern4   1  2  1  3
Pattern5   1  2  3  4
Pattern6   1  1  1  1
Pattern7   1  2  1  2
Pattern8   1  1  2  1
Pattern9   1  2  1  1
Pattern10  1  1  2  2
Pattern11  1  2  2  2
Pattern12  1  2  3  2
\end{Soutput}
\end{Schunk}

\noindent The posterior probability of being in each pattern for every gene is obtained by using the 
function \verb+GetMultiPP+:
\begin{Schunk}
\begin{Sinput}
> IsoMultiPP=GetMultiPP(IsoMultiOut)
> names(MultiPP)
\end{Sinput}
\begin{Soutput}
[1] "PP"       "MAP"      "Patterns"
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$PP[1:10,]
\end{Sinput}
\begin{Soutput}
             pattern1     pattern2     pattern3     pattern4     pattern5
Iso_1_1  9.944829e-01 2.487951e-03 1.268388e-03 1.758950e-03 1.771681e-06
Iso_1_2  9.912427e-01 2.969262e-03 3.149008e-03 2.634129e-03 4.875175e-06
Iso_1_3  9.511978e-01 3.810283e-02 8.491698e-03 2.162905e-03 4.476499e-05
Iso_1_4  9.894764e-01 5.116263e-03 2.454048e-03 2.946992e-03 6.317775e-06
Iso_1_5  9.991552e-01 7.293563e-05 1.735210e-04 5.983095e-04 2.165350e-08
Iso_1_6  5.281437e-05 9.992943e-01 7.313762e-07 3.257042e-05 6.196223e-04
Iso_1_7  9.934368e-01 1.784738e-03 2.173345e-03 2.602521e-03 2.640945e-06
Iso_1_8  8.288801e-01 1.595626e-01 1.813693e-03 9.599158e-03 1.444232e-04
Iso_1_9  7.704437e-01 2.182868e-01 2.149635e-03 8.906145e-03 2.136948e-04
Iso_1_10 9.913102e-01 3.714386e-03 2.129945e-03 2.838316e-03 4.514167e-06
              pattern6      pattern7      pattern8      pattern9     pattern10
Iso_1_1   6.547737e-32  7.334070e-28  7.444297e-33  1.187580e-33  7.826127e-30
Iso_1_2   6.429034e-14  2.381428e-15  3.864389e-16  1.449241e-15  4.027626e-15
Iso_1_3   1.182199e-46  6.734763e-38  9.816011e-42  1.000115e-47  9.124439e-46
Iso_1_4   6.216584e-35  1.237632e-20  2.301442e-30  6.596860e-32  7.318319e-23
Iso_1_5   0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00
Iso_1_6  4.033350e-234 4.955181e-156 1.142613e-221 3.682627e-183 3.684941e-101
Iso_1_7  5.630249e-138 6.431489e-104 1.006944e-132 2.204727e-135 3.261238e-110
Iso_1_8  1.467526e-138  2.610835e-67 3.869222e-105 8.031404e-123  4.969433e-88
Iso_1_9   3.352994e-47  2.274798e-45  1.364332e-50  1.007720e-43  8.001378e-30
Iso_1_10  5.983367e-08  1.870470e-06  1.057221e-09  1.094014e-09  6.574554e-07
             pattern11     pattern12
Iso_1_1   4.409921e-34  4.382372e-30
Iso_1_2   1.304877e-17  2.614705e-17
Iso_1_3   8.498244e-50  8.269050e-39
Iso_1_4   5.692183e-33  1.574014e-22
Iso_1_5   0.000000e+00  0.000000e+00
Iso_1_6  2.865219e-189 5.592363e-154
Iso_1_7  2.057379e-128 3.871764e-106
Iso_1_8  5.645298e-120  2.330319e-68
Iso_1_9   4.875946e-46  3.238016e-46
Iso_1_10  1.013843e-09  1.764817e-08
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$MAP[1:10]
\end{Sinput}
\begin{Soutput}
   Iso_1_1    Iso_1_2    Iso_1_3    Iso_1_4    Iso_1_5    Iso_1_6    Iso_1_7 
"pattern1" "pattern1" "pattern1" "pattern1" "pattern1" "pattern2" "pattern1" 
   Iso_1_8    Iso_1_9   Iso_1_10 
"pattern1" "pattern1" "pattern1" 
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$Patterns
\end{Sinput}
\begin{Soutput}
          C1 C2 C3 C4
Pattern1   1  1  1  2
Pattern2   1  1  2  3
Pattern3   1  2  2  3
Pattern4   1  2  1  3
Pattern5   1  2  3  4
Pattern6   1  1  1  1
Pattern7   1  2  1  2
Pattern8   1  1  2  1
Pattern9   1  2  1  1
Pattern10  1  1  2  2
Pattern11  1  2  2  2
Pattern12  1  2  3  2
\end{Soutput}
\end{Schunk}
\noindent where \verb+MultiPP$PP+ provides the posterior probability of being in each pattern for every gene. 
\verb+MultiPP$MAP+ provides the most likely pattern of each gene based on the posterior 
probabilities. \verb+MultiPP$Patterns+ provides the details of the patterns. 



\newpage
\section{More detailed examples}
\label{sec:detailed}
\subsection{Gene level DE analysis (two conditions)}
\label{sec:detailedgenede}

\subsubsection{Running EBSeq on simulated gene expression estimates}
\label{sec:detailedgenederun}
EBSeq is applied as described in Section \ref{sec:startgenederun}.
\begin{Schunk}
\begin{Sinput}
> data(GeneMat)
> Sizes=MedianNorm(GeneMat)
> EBOut=EBTest(Data=GeneMat, 
+ Conditions=as.factor(rep(c("C1","C2"),each=5)),sizeFactors=Sizes)
> EBDERes=GetDEResults(EBOut, FDR=0.05)
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> EBDERes=GetDEResults(EBOut, FDR=0.05)
> str(EBDERes$DEfound)
\end{Sinput}
\begin{Soutput}
 chr [1:94] "Gene_1" "Gene_2" "Gene_3" "Gene_4" "Gene_5" "Gene_6" "Gene_7" ...
\end{Soutput}
\begin{Sinput}
> head(EBDERes$PPMat)
\end{Sinput}
\begin{Soutput}
                PPEE PPDE
Gene_1  0.000000e+00    1
Gene_2  6.831008e-47    1
Gene_3 1.070213e-218    1
Gene_4  2.085332e-33    1
Gene_5 1.907801e-229    1
Gene_6  1.170782e-09    1
\end{Soutput}
\begin{Sinput}
> str(EBDERes$Status)
\end{Sinput}
\begin{Soutput}
 Named chr [1:1000] "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" "DE" ...
 - attr(*, "names")= chr [1:1000] "Gene_1" "Gene_2" "Gene_3" "Gene_4" ...
\end{Soutput}
\end{Schunk}
\noindent EBSeq found 94 DE genes at a target FDR of 0.05.\\

\subsubsection{Calculating FC}
\label{sec:detailedgenedefc}
The function \verb+PostFC+ may be used to calculate the Fold Change (FC) 
of the raw data as well as the posterior FC of the normalized data.
\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> GeneFC=PostFC(EBOut)
> str(GeneFC)
\end{Sinput}
\begin{Soutput}
List of 3
 $ PostFC   : num [1:1000, 1] 0.237 0.241 4.127 4.237 3.909 ...
 $ RealFC   : Named num [1:1000] 0.237 0.239 4.128 4.28 3.918 ...
  ..- attr(*, "names")= chr [1:1000] "Gene_1" "Gene_2" "Gene_3" "Gene_4" ...
 $ Direction: chr "C1 Over C2"
\end{Soutput}
\begin{Sinput}
> PlotPostVsRawFC(EBOut,GeneFC)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-021}
\caption{
FC vs. Posterior FC for 1,000 gene expression estimates}
\label{fig:GeneFC}
\end{figure}
Figure \ref{fig:GeneFC} shows the FC vs. Posterior FC on 1,000 gene expression estimates. 
The genes are ranked by their cross-condition mean (adjusted by the normalization factors). 
The posterior FC tends to shrink genes with low expressions (small rank); in this case the differences
are minor. 


\newpage

\subsubsection{Checking convergence}
\label{sec:detailedgenedeconverge}
As detailed in Section \ref{sec:model}, we assume the prior distribution of $q_g^C$ is 
$Beta(\alpha,\beta)$. The EM algorithm is used to estimate the 
hyper-parameters $\alpha,\beta$ and the mixture parameter $p$. 
The optimized parameters may be obtained as follows : 
\begin{Schunk}
\begin{Sinput}
> EBOut$Alpha
\end{Sinput}
\begin{Soutput}
[1] 0.4064996
\end{Soutput}
\begin{Sinput}
> EBOut$Beta[1:5]
\end{Sinput}
\begin{Soutput}
[1] 1.955348 1.907624 1.954959 1.931728 1.816152
\end{Soutput}
\begin{Sinput}
> EBOut$P
\end{Sinput}
\begin{Soutput}
[1] 0.1082901 0.8917099
\end{Soutput}
\end{Schunk}

The one-step EM will stop if the difference between the objectives(marginal likelihood) at two iterations is smaller than the \verb+stopthre+ (default as 1e-4) or the \verb+maxround+(default as 50) number of iterations has been reached. 


\subsubsection{Checking the model fit and other diagnostics}
\label{sec:detailedgenedeplot}
As noted in Leng {\it et al.}, 2013 \cite{Leng13}, EBSeq relies on parametric assumptions that should
be checked following each analysis.
The \verb+QQP+ function may be used to assess prior assumptions. 
In practice, \verb+QQP+ generates the Q-Q plot of the empirical $q$'s 
vs. the simulated $q$'s from the Beta prior distribution with 
estimated hyper-parameters. Figure \ref{fig:GeneQQ} shows that the 
data points lie on the $y=x$ line for both conditions, which indicates 
that the Beta prior is appropriate.

\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(1,2))
> QQP(EBOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-023}
\caption{QQ-plots for checking the assumption of a Beta prior (upper panels) as well as the
model fit using data from condition 1 and condition 2 (lower panels)}
\label{fig:GeneQQ}
\end{figure}

\newpage
\noindent  
Likewise, the \verb+DenNHist+ function may be used to check the density plot of empirical $q$'s vs the simulated
$q$'s from the fitted Beta prior distribution. 
Figure \ref{fig:GeneDenNHist} also shows our estimated distribution fits the 
data very well.

\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(1,2))
> DenNHist(EBOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-024}
\caption{Density plots for checking the model fit using data from condition 1 and condition 2}
\label{fig:GeneDenNHist}
\end{figure}

\newpage
\subsection{Isoform level DE analysis (two conditions)}
\label{sec:detailedisode}
\subsubsection{The $I_g$ vector}
\label{sec:detailedisodeNg}
Since EBSeq fits rely on $I_g$, 
we need to obtain the $I_g$ for each isoform. This can be done using the 
function \verb+GetNg+. 
The required inputs of \verb+GetNg+ are the isoform names (\verb+IsoformNames+) and 
their corresponding gene names (\verb+IsosGeneNames+), described above.
In the simulated data, we assume that the isoforms in the $I_g=1$ group belong to genes \verb+Gene_1, ... , Gene_200+; 
The isoforms in the $I_g=2$ group belong to genes 
\verb+Gene_201, ..., Gene_400+; and isoforms in the $I_g=3$ group 
belong to \verb+Gene_401, ..., Gene_600+.

\begin{Schunk}
\begin{Sinput}
> data(IsoList)
> IsoMat=IsoList$IsoMat
> IsoNames=IsoList$IsoNames
> IsosGeneNames=IsoList$IsosGeneNames
> NgList=GetNg(IsoNames, IsosGeneNames, TrunThre=3)
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> names(NgList)
\end{Sinput}
\begin{Soutput}
[1] "GeneNg"        "GeneNgTrun"    "IsoformNg"     "IsoformNgTrun"
\end{Soutput}
\begin{Sinput}
> IsoNgTrun=NgList$IsoformNgTrun
> IsoNgTrun[c(1:3,201:203,601:603)]
\end{Sinput}
\begin{Soutput}
Iso_1_1 Iso_1_2 Iso_1_3 Iso_2_1 Iso_2_2 Iso_2_3 Iso_3_1 Iso_3_2 Iso_3_3 
      1       1       1       2       2       2       3       3       3 
\end{Soutput}
\end{Schunk}

The output of \verb+GetNg+ contains 4 vectors. \verb+GeneNg+ (\verb+IsoformNg+) provides 
the number of isoforms $N_g$ within each gene (within each isoform's host gene). 
\verb+GeneNgTrun+ (\verb+IsoformNgTrun+) provides the $I_g$ group assignments. 
The default number of groups is 3, which means the isoforms  
with $N_g$  greater than 3 will be assigned to $I_g=3$ group.
We use 3 in the case studies 
since the number of isoforms with $N_g$ larger than 3 is relatively small and 
the small sample size may induce poor parameter fitting if we treat them 
as separate groups.  
In practice, if there is evidence that the $N_g=4,5,6...$ groups should be 
treated as separate groups, a user can change \verb+TrunThre+ to define 
a different truncation threshold.

\subsubsection{Using mappability ambiguity clusters instead of 
the $I_g$ vector when the gene-isoform relationship is unknown}
\label{sec:detailedisodeNoNg}
When working with a de-novo assembled transcriptome, in which case the gene-isoform 
relationship is unknown, 
a user can use read mapping ambiguity cluster information instead of Ng,
as provided by RSEM \cite{Li11b} in the
output file \verb+output_name.ngvec+. The file contains a vector with the same 
length as the total number of transcripts. 
Each transcript has been assigned to one of 3 levels 
(1, 2, or 3) to indicate the mapping uncertainty level of that transcript. 
The mapping ambiguity clusters are partitioned via a k-means algorithm on the unmapability 
scores that are provided by RSEM.  A user can read in the mapping ambiguity cluster information  
using:

\begin{Schunk}
\begin{Sinput}
> IsoNgTrun = scan(file="output_name.ngvec", what=0, sep="\n")
\end{Sinput}
\end{Schunk}
Where \verb+"output_name.ngvec"+ is the output file obtained from RSEM function rsem-generate-ngvector. 
More details on using the RSEM-EBSeq pipeline 
on de novo assembled transcriptomes can be found 
at \url{http://deweylab.biostat.wisc.edu/rsem/README.html#de}.

Other unmappability scores and other cluster methods (e.g. Gaussian Mixed Model) 
could also be used to form the uncertainty clusters.

\subsubsection{Running EBSeq on simulated isoform expression estimates}
\label{sec:detailedisoderun}
EBSeq can be applied as described in Section \ref{sec:startisoderun}.
\begin{Schunk}
\begin{Sinput}
> IsoSizes=MedianNorm(IsoMat)
> IsoEBOut=EBTest(Data=IsoMat, NgVector=IsoNgTrun, 
+ Conditions=as.factor(rep(c("C1","C2"),each=5)),sizeFactors=IsoSizes,step2 = 1e-4)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 2
Final number of DE patterns = 2
\end{Soutput}
\begin{Sinput}
> IsoEBDERes=GetDEResults(IsoEBOut, FDR=0.05)
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> str(IsoEBDERes)
\end{Sinput}
\begin{Soutput}
List of 3
 $ DEfound: chr [1:105] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
 $ PPMat  : num [1:1200, 1:2] 6.89e-19 1.43e-83 0.00 3.19e-206 2.26e-71 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
  .. ..$ : chr [1:2] "PPEE" "PPDE"
 $ Status : Named chr [1:1200] "DE" "DE" "DE" "DE" ...
  ..- attr(*, "names")= chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
\end{Soutput}
\end{Schunk}
\noindent We see that EBSeq found 104 DE isoforms at a target FDR of 0.05. 
The function \verb+PostFC+ could also be used here to calculate the Fold Change (FC) 
as well as the posterior FC on the normalization factor adjusted data.
\begin{Schunk}
\begin{Sinput}
> IsoFC=PostFC(IsoEBOut)
> str(IsoFC)
\end{Sinput}
\begin{Soutput}
List of 3
 $ PostFC   : num [1:1200, 1] 0.286 0.281 3.553 0.305 3.755 ...
 $ RealFC   : Named num [1:1200] 0.285 0.281 3.556 0.305 3.759 ...
  ..- attr(*, "names")= chr [1:1200] "Iso_1_1" "Iso_1_2" "Iso_1_3" "Iso_1_4" ...
 $ Direction: chr "C1 Over C2"
\end{Soutput}
\end{Schunk}


\subsubsection{Checking convergence}
\label{sec:detailedisodeconverge}
For isoform level data, we assume the prior distribution of $q_{gi}^C$ is
$Beta(\alpha,\beta^{I_g})$.
As in Section \ref{sec:detailedgenedeconverge}, the optimized parameters 
may be obtained as follows: 
\begin{Schunk}
\begin{Sinput}
> IsoEBOut$Alpha
\end{Sinput}
\begin{Soutput}
[1] 0.4035282
\end{Soutput}
\begin{Sinput}
> unique(IsoEBOut$Beta)
\end{Sinput}
\begin{Soutput}
[1] 1.898653 1.830985 1.764382
\end{Soutput}
\begin{Sinput}
> IsoEBOut$P
\end{Sinput}
\begin{Soutput}
[1] 0.1328323 0.8671677
\end{Soutput}
\end{Schunk}
Here we have 3 $\beta$'s in each iteration corresponding to 
$\beta^{I_g=1},\beta^{I_g=2},\beta^{I_g=3}$.

The one-step EM will stop if the difference between the objectives(marginal likelihood) at two iterations is smaller than the \verb+stopthre+ (default as 1e-4) or the \verb+maxround+(default as 50) number of iterations has been reached. 

\subsubsection{Checking the model fit and other diagnostics}
\label{sec:detailedisodeplot}
In Leng {\it et al.}, 2013\citep{Leng13}, we showed the mean-variance differences across different 
isoform groups on multiple data sets. 
In practice, if it is of interest to check differences among 
isoform groups defined by truncated $I_g$ (such as those shown here
in Figure 1), the function \verb+PolyFitPlot+ may be used. 
The following code generates the three
panels shown in Figure \ref{fig:IsoSimuNgEach}
(if condition 2 is of interest, a user could change each \verb+group = 1 + to \verb+group = 2+.):
\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(2,2))
> PolyFitValue=vector("list",3)
> for(i in 1:3){
+   group = 1
+   PolyFitValue[[i]]=PolyFitPlot(IsoEBOut$Mean[which(IsoEBOut$Iso == i),group], 
+     IsoEBOut$Var[which(IsoEBOut$Iso == i),group],5)
+ }
>     
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-032}
\caption{ The mean-variance fitting plot for each Ng group}
\label{fig:IsoSimuNgEach}
\end{figure}

\newpage
Superimposing all $I_g$ groups using the code below will generate the figure (shown 
here in Figure \ref{fig:IsoSimuNg}), which is similar in structure to Figure 1:


\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> group = 1
> X = IsoEBOut$Mean[,group]
> Y = IsoEBOut$Var[,group]
> PolyAll=PolyFitPlot(X, Y,5)
> lines(log10(X[which(IsoEBOut$Iso == 1)][PolyFitValue[[1]]$sort]), 
+ PolyFitValue[[1]]$fit[PolyFitValue[[1]]$sort],col="yellow",lwd=2)
> lines(log10(X[which(IsoEBOut$Iso == 2)][PolyFitValue[[2]]$sort]), 
+ PolyFitValue[[2]]$fit[PolyFitValue[[2]]$sort],col="pink",lwd=2)
> lines(log10(X[which(IsoEBOut$Iso == 3)][PolyFitValue[[3]]$sort]), 
+ PolyFitValue[[3]]$fit[PolyFitValue[[3]]$sort],col="green",lwd=2)
> legend("topleft",c("All Isoforms","Ng = 1","Ng = 2","Ng = 3"),
+ col=c("red","yellow","pink","green"),lty=1,lwd=3,box.lwd=2)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-033}
\caption{The mean-variance plot for each Ng group}
\label{fig:IsoSimuNg}
\end{figure}


\newpage
\noindent To generate a QQ-plot of the fitted Beta prior distribution 
and the $\hat{q}^C$'s within condition, a user may 
use the following code to generate 6 panels (as shown in Figure \ref{fig:IsoQQ}).
\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(2,3))
> QQP(IsoEBOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-034}
\caption{ QQ-plots of the fitted prior distributions within each condition and each Ig group}
\label{fig:IsoQQ}
\end{figure}

\newpage
\noindent And in order to produce the plot of the fitted Beta prior densities
and the histograms of $\hat{q}^C$'s within each condition, 
the following may be used (it generates Figure \ref{fig:IsoDenNHist}):
\begin{figure}[h]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(2,3))
> DenNHist(IsoEBOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-035}
\caption{ Prior distribution fit within each condition and each Ig group.
(Note only a small set of isoforms are considered here for demonstration.
Better fitting should be expected while using full set of isoforms.)}
\label{fig:IsoDenNHist}
\end{figure}

\clearpage
\subsection{Gene level DE analysis (more than two conditions)}
\label{sec:detailedmulticond}
\noindent 
\verb+MedianNorm+ or one of its competitors should be used to determine the normalization factors.
Once this is done, the formal test is performed by \verb+EBMultiTest+. 
\begin{Schunk}
\begin{Sinput}
> data(MultiGeneMat)
> Conditions=c("C1","C1","C2","C2","C3","C3")
> MultiSize=MedianNorm(MultiGeneMat)
> MultiOut=EBMultiTest(MultiGeneMat,
+ NgVector=NULL,Conditions=Conditions,
+ sizeFactors=MultiSize, uc = 2)
\end{Sinput}
\end{Schunk}
\noindent The posterior probability of being in each pattern for every gene is obtained using the 
function \verb+GetMultiPP+:
\begin{Schunk}
\begin{Sinput}
> MultiPP=GetMultiPP(MultiOut)
> names(MultiPP)
\end{Sinput}
\begin{Soutput}
[1] "PP"       "MAP"      "Patterns"
\end{Soutput}
\begin{Sinput}
> MultiPP$PP[1:10,]
\end{Sinput}
\begin{Soutput}
           pattern1  pattern2      pattern3      pattern4      pattern5
Gene_1  0.342709563 0.6572904  6.870408e-72  3.015440e-93  2.864790e-55
Gene_3  0.006595105 0.9934049 5.340316e-109 3.433672e-163 2.922145e-116
Gene_5  0.042482476 0.9575175  5.309949e-20  7.837887e-26  1.140460e-18
Gene_7  0.157609361 0.8423906  0.000000e+00  0.000000e+00 2.905691e-294
Gene_9  0.040619174 0.9593808  2.441999e-15  9.088562e-16  9.343836e-16
Gene_11 0.053841782 0.9461582  2.607784e-12  2.955394e-11  4.570651e-11
Gene_13 0.106486219 0.8935129  9.194008e-10  6.798796e-08  7.735994e-07
Gene_15 0.027054430 0.9729456  1.079379e-40  5.379139e-47  2.410435e-44
Gene_17 0.181376143 0.8186239 4.590012e-133 7.310837e-184 9.831129e-113
Gene_19 0.048700449 0.9512996  1.080862e-24  2.792245e-37  6.753301e-28
\end{Soutput}
\begin{Sinput}
> MultiPP$MAP[1:10]
\end{Sinput}
\begin{Soutput}
    Gene_1     Gene_3     Gene_5     Gene_7     Gene_9    Gene_11    Gene_13 
"pattern2" "pattern2" "pattern2" "pattern2" "pattern2" "pattern2" "pattern2" 
   Gene_15    Gene_17    Gene_19 
"pattern2" "pattern2" "pattern2" 
\end{Soutput}
\begin{Sinput}
> MultiPP$Patterns
\end{Sinput}
\begin{Soutput}
         C1 C2 C3
Pattern1  1  2  3
Pattern2  1  1  2
Pattern3  1  2  2
Pattern4  1  1  1
Pattern5  1  2  1
\end{Soutput}
\end{Schunk}
As described in Section \ref{sec:startmulticond}, 
the function \verb+GetPatterns+ allows the user to get selected patterns after we run the \verb+EBMultiTest+ function
To visualize the patterns, the function \verb+PlotPattern+ may be used.

\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> PosParti=GetPatterns(MultiOut)
> PosParti
\end{Sinput}
\begin{Soutput}
         C1 C2 C3
Pattern1  1  2  3
Pattern2  1  1  2
Pattern3  1  2  2
Pattern4  1  1  1
Pattern5  1  2  1
\end{Soutput}
\begin{Sinput}
> PlotPattern(PosParti)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-038}
\caption{ Selected patterns, for this case, happens to be all possible patterns for 3 conditions}
\label{fig:Patterns}
\end{figure}
\newpage
\noindent where \verb+MultiPP$PP+ provides the posterior probability of being in each pattern for every gene. 
\verb+MultiPP$MAP+ provides the most likely pattern of each gene based on the posterior 
probabilities. \verb+MultiPP$Patterns+ provides the details of the patterns.  The FC and posterior FC for multiple condition data can
be obtained by the function \verb+GetMultiFC+:

\begin{Schunk}
\begin{Sinput}
> MultiFC=GetMultiFC(MultiOut)
> str(MultiFC)
\end{Sinput}
\begin{Soutput}
List of 6
 $ FCMat         : num [1:500, 1:3] 1.217 0.951 1.069 0.923 0.983 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:500] "Gene_1" "Gene_3" "Gene_5" "Gene_7" ...
  .. ..$ : chr [1:3] "C1 Over C2" "C1 Over C3" "C2 Over C3"
 $ Log2FCMat     : num [1:500, 1:3] 0.2828 -0.0724 0.0969 -0.1151 -0.0251 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:500] "Gene_1" "Gene_3" "Gene_5" "Gene_7" ...
  .. ..$ : chr [1:3] "C1 Over C2" "C1 Over C3" "C2 Over C3"
 $ PostFCMat     : num [1:500, 1:3] 1.216 0.951 1.069 0.923 0.983 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:500] "Gene_1" "Gene_3" "Gene_5" "Gene_7" ...
  .. ..$ : chr [1:3] "C1 Over C2" "C1 Over C3" "C2 Over C3"
 $ Log2PostFCMat : num [1:500, 1:3] 0.2822 -0.0722 0.0967 -0.115 -0.0251 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:500] "Gene_1" "Gene_3" "Gene_5" "Gene_7" ...
  .. ..$ : chr [1:3] "C1 Over C2" "C1 Over C3" "C2 Over C3"
 $ CondMeans     : num [1:500, 1:3] 499 253 813 1843 753 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:3] "C1" "C2" "C3"
 $ ConditionOrder: Factor w/ 3 levels "C1","C2","C3": 1 1 2 2 3 3
\end{Soutput}
\end{Schunk}

\noindent To generate a QQ-plot of the fitted Beta prior distribution 
and the $\hat{q}^C$'s within condition, a user could also use function 
\verb+DenNHist+ and \verb+QQP+.

\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(2,2))
> QQP(MultiOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-040}
\caption{ QQ-plots of the fitted prior distributions within each condition and each Ig group}
\label{fig:GeneMultiQQ}
\end{figure}

\begin{figure}[h]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(2,2))
> DenNHist(MultiOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-041}
\caption{ Prior distributions fit within each condition. 
(Note only a small set of genes are considered here for demonstration.
Better fitting should be expected while using full set of genes.)}
\label{fig:GeneMultiDenNHist}
\end{figure}
\newpage
\clearpage
\newpage
\subsection{Isoform level DE analysis (more than two conditions)}
\label{sec:detailedisomulticond}

\begin{Schunk}
\begin{Sinput}
> data(IsoMultiList)
> Conditions=c("C1","C1","C2","C2","C3","C3","C4","C4")
> IsoMultiMat=IsoMultiList[[1]]
> IsoNames.Multi=IsoMultiList$IsoNames
> IsosGeneNames.Multi=IsoMultiList$IsosGeneNames
> IsoMultiSize=MedianNorm(IsoMultiMat)
> NgList.Multi=GetNg(IsoNames.Multi, IsosGeneNames.Multi)
> IsoNgTrun.Multi=NgList.Multi$IsoformNgTrun
> IsoMultiOut=EBMultiTest(IsoMultiMat,NgVector=IsoNgTrun.Multi,Conditions=Conditions,
+ sizeFactors=IsoMultiSize, uc = 2)
> IsoMultiPP=GetMultiPP(IsoMultiOut)
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> names(MultiPP)
\end{Sinput}
\begin{Soutput}
[1] "PP"       "MAP"      "Patterns"
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$PP[1:10,]
\end{Sinput}
\begin{Soutput}
             pattern1     pattern2     pattern3     pattern4     pattern5
Iso_1_1  9.944829e-01 2.487951e-03 1.268388e-03 1.758950e-03 1.771681e-06
Iso_1_2  9.912427e-01 2.969262e-03 3.149008e-03 2.634129e-03 4.875175e-06
Iso_1_3  9.511978e-01 3.810283e-02 8.491698e-03 2.162905e-03 4.476499e-05
Iso_1_4  9.894764e-01 5.116263e-03 2.454048e-03 2.946992e-03 6.317775e-06
Iso_1_5  9.991552e-01 7.293563e-05 1.735210e-04 5.983095e-04 2.165350e-08
Iso_1_6  5.281437e-05 9.992943e-01 7.313762e-07 3.257042e-05 6.196223e-04
Iso_1_7  9.934368e-01 1.784738e-03 2.173345e-03 2.602521e-03 2.640945e-06
Iso_1_8  8.288801e-01 1.595626e-01 1.813693e-03 9.599158e-03 1.444232e-04
Iso_1_9  7.704437e-01 2.182868e-01 2.149635e-03 8.906145e-03 2.136948e-04
Iso_1_10 9.913102e-01 3.714386e-03 2.129945e-03 2.838316e-03 4.514167e-06
              pattern6      pattern7      pattern8      pattern9     pattern10
Iso_1_1   6.547737e-32  7.334070e-28  7.444297e-33  1.187580e-33  7.826127e-30
Iso_1_2   6.429034e-14  2.381428e-15  3.864389e-16  1.449241e-15  4.027626e-15
Iso_1_3   1.182199e-46  6.734763e-38  9.816011e-42  1.000115e-47  9.124439e-46
Iso_1_4   6.216584e-35  1.237632e-20  2.301442e-30  6.596860e-32  7.318319e-23
Iso_1_5   0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00
Iso_1_6  4.033350e-234 4.955181e-156 1.142613e-221 3.682627e-183 3.684941e-101
Iso_1_7  5.630249e-138 6.431489e-104 1.006944e-132 2.204727e-135 3.261238e-110
Iso_1_8  1.467526e-138  2.610835e-67 3.869222e-105 8.031404e-123  4.969433e-88
Iso_1_9   3.352994e-47  2.274798e-45  1.364332e-50  1.007720e-43  8.001378e-30
Iso_1_10  5.983367e-08  1.870470e-06  1.057221e-09  1.094014e-09  6.574554e-07
             pattern11     pattern12
Iso_1_1   4.409921e-34  4.382372e-30
Iso_1_2   1.304877e-17  2.614705e-17
Iso_1_3   8.498244e-50  8.269050e-39
Iso_1_4   5.692183e-33  1.574014e-22
Iso_1_5   0.000000e+00  0.000000e+00
Iso_1_6  2.865219e-189 5.592363e-154
Iso_1_7  2.057379e-128 3.871764e-106
Iso_1_8  5.645298e-120  2.330319e-68
Iso_1_9   4.875946e-46  3.238016e-46
Iso_1_10  1.013843e-09  1.764817e-08
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$MAP[1:10]
\end{Sinput}
\begin{Soutput}
   Iso_1_1    Iso_1_2    Iso_1_3    Iso_1_4    Iso_1_5    Iso_1_6    Iso_1_7 
"pattern1" "pattern1" "pattern1" "pattern1" "pattern1" "pattern2" "pattern1" 
   Iso_1_8    Iso_1_9   Iso_1_10 
"pattern1" "pattern1" "pattern1" 
\end{Soutput}
\begin{Sinput}
> IsoMultiPP$Patterns
\end{Sinput}
\begin{Soutput}
          C1 C2 C3 C4
Pattern1   1  1  1  2
Pattern2   1  1  2  3
Pattern3   1  2  2  3
Pattern4   1  2  1  3
Pattern5   1  2  3  4
Pattern6   1  1  1  1
Pattern7   1  2  1  2
Pattern8   1  1  2  1
Pattern9   1  2  1  1
Pattern10  1  1  2  2
Pattern11  1  2  2  2
Pattern12  1  2  3  2
\end{Soutput}
\begin{Sinput}
> IsoMultiFC=GetMultiFC(IsoMultiOut)
\end{Sinput}
\end{Schunk}

Similar to Section \ref{sec:startmulticond}, 
the function \verb+GetPatterns+ allows a user to get selected patterns.
To visualize the patterns, the function \verb+PlotPattern+ may be used.
\begin{Schunk}
\begin{Sinput}
> PosParti.4Cond=GetPatterns(IsoMultiOut)
> PosParti.4Cond
\end{Sinput}
\begin{Soutput}
          C1 C2 C3 C4
Pattern1   1  1  1  2
Pattern2   1  1  2  3
Pattern3   1  2  2  3
Pattern4   1  2  1  3
Pattern5   1  2  3  4
Pattern6   1  1  1  1
Pattern7   1  2  1  2
Pattern8   1  1  2  1
Pattern9   1  2  1  1
Pattern10  1  1  2  2
Pattern11  1  2  2  2
Pattern12  1  2  3  2
\end{Soutput}
\end{Schunk}

\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> PlotPattern(PosParti.4Cond)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-045}
\caption{Selected patterns for 4 conditions}
\label{fig:Patterns4Cond}
\end{figure}
\newpage


The FC and posterior FC for multiple condition data can be obtained by the function \verb+GetMultiFC+:


\noindent To generate a QQ-plot of the fitted Beta prior distribution 
and the $\hat{q}^C$'s within condition, a user could also use the functions 
\verb+DenNHist+ and \verb+QQP+.
\newpage
\begin{figure}[h!]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(3,4))
> QQP(IsoMultiOut)
> 
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-046}
\caption{ QQ-plots of the fitted prior distributions within each condition and Ig group. 
(Note only a small set of isoforms are considered here for demonstration.
Better fitting should be expected while using full set of isoforms.)}
\label{fig:IsoMultiQQ}
\end{figure}

\begin{figure}[h]
\centering
\begin{Schunk}
\begin{Sinput}
> par(mfrow=c(3,4))
> DenNHist(IsoMultiOut)
\end{Sinput}
\end{Schunk}
\includegraphics{EBSeq_Vignette-047}
\caption{ Prior distributions fit within each condition and Ig group. 
(Note only a small set of isoforms are considered here for demonstration.
Better fitting should be expected while using full set of isoforms.)}
\label{fig:IsoMultiDenNHist}
\end{figure}
\clearpage
\newpage


\newpage
\subsection{Working without replicates}
When replicates are not available, it is difficult to estimate the transcript specific variance.
In this case, EBSeq estimates the variance by  pooling similar genes together.  
Specifically, we take genes with FC in the 25\% - 75\% quantile of all FC's as 
candidate genes. By defining \verb+NumBin = 1000+ (default in \verb+EBTest+), EBSeq 
will group genes with similar means into 1,000 bins. 
For each candidate gene, we use the across-condition variance estimate as its variance estimate. 
For each bin, the bin-wise variance estimation is taken to be the median of the 
across-condition variance estimates of the candidate genes within that bin. 
For each non-candidate gene, we use the bin-wise variance estimate of the host bin (the bin containing this gene) 
as its variance estimate.
This approach works well when there are no more than 50\% DE genes in the data set. 

\subsubsection{Gene counts with two conditions}
\label{sec:norepgenede}

To generate a data set with no replicates, we take the first sample of each condition. 
For example, using the data from Section \ref{sec:detailedgenede}, we take sample 1 from condition 1 and 
sample 6 from condition 2. Functions \verb+MedianNorm+, \verb+GetDEResults+ and 
\verb+PostFC+ may be used on data without replicates.
\begin{Schunk}
\begin{Sinput}
> data(GeneMat)
> GeneMat.norep=GeneMat[,c(1,6)]
> Sizes.norep=MedianNorm(GeneMat.norep)
> EBOut.norep=EBTest(Data=GeneMat.norep,
+ Conditions=as.factor(rep(c("C1","C2"))),
+ sizeFactors=Sizes.norep)
\end{Sinput}
\begin{Soutput}
Removing transcripts with 100 th quantile < = 0 
999 transcripts will be tested
Initial number of DE patterns = 2
Final number of DE patterns = 2
\end{Soutput}
\begin{Sinput}
> EBDERes.norep=GetDEResults(EBOut.norep)
> GeneFC.norep=PostFC(EBOut.norep)
\end{Sinput}
\end{Schunk}

\subsubsection{Isoform counts with two conditions}
\label{norepisode}
To generate an isoform level data set with no replicates, we
also take sample 1 and sample 6 in the data we used in Section
\ref{sec:detailedisode}. 
Example codes are shown below.

\begin{Schunk}
\begin{Sinput}
> data(IsoList)
> IsoMat=IsoList$IsoMat
> IsoNames=IsoList$IsoNames
> IsosGeneNames=IsoList$IsosGeneNames
> NgList=GetNg(IsoNames, IsosGeneNames)
> IsoNgTrun=NgList$IsoformNgTrun
> IsoMat.norep=IsoMat[,c(1,6)]
> IsoSizes.norep=MedianNorm(IsoMat.norep)
> IsoEBOut.norep=EBTest(Data=IsoMat.norep, NgVector=IsoNgTrun,
+ Conditions=as.factor(c("C1","C2")),
+ sizeFactors=IsoSizes.norep)
\end{Sinput}
\begin{Soutput}
Removing transcripts with 100 th quantile < = 0 
1192 transcripts will be tested
Initial number of DE patterns = 2
Final number of DE patterns = 2
\end{Soutput}
\begin{Sinput}
> IsoEBDERes.norep=GetDEResults(IsoEBOut.norep)
> IsoFC.norep=PostFC(IsoEBOut.norep)
\end{Sinput}
\end{Schunk}

\subsubsection{Gene counts with more than two conditions}
\label{norepisode}
To generate a data set with multiple conditions and no replicates, 
we take the first sample from each condition (sample 1, 3 and 5) in the data we used
in Section \ref{sec:detailedmulticond}. 
Example codes are shown below.
\begin{Schunk}
\begin{Sinput}
> data(MultiGeneMat)
> MultiGeneMat.norep=MultiGeneMat[,c(1,3,5)]
> Conditions=c("C1","C2","C3")
> #PosParti=GetPatterns(Conditions)
> #Parti=PosParti[-3,]
> MultiSize.norep=MedianNorm(MultiGeneMat.norep)
> MultiOut.norep=EBMultiTest(MultiGeneMat.norep,
+ NgVector=NULL,Conditions=Conditions, sizeFactors=MultiSize.norep, 
+ uc =2)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 5
Final number of DE patterns = 5
\end{Soutput}
\begin{Sinput}
> MultiPP.norep=GetMultiPP(MultiOut.norep)
> MultiFC.norep=GetMultiFC(MultiOut.norep)
\end{Sinput}
\end{Schunk}

\subsubsection{Isoform counts with more than two conditions}
\label{sec:norepmulticond}
To generate an isoform level data set with multiple conditions and no replicates,
we take the first sample from each condition (sample 1, 3, 5 and 7) in the data we used
in Section \ref{sec:detailedisomulticond}. 
Example codes are shown below.



\begin{Schunk}
\begin{Sinput}
> data(IsoMultiList)
> IsoMultiMat=IsoMultiList[[1]]
> IsoNames.Multi=IsoMultiList$IsoNames
> IsosGeneNames.Multi=IsoMultiList$IsosGeneNames
> IsoMultiMat.norep=IsoMultiMat[,c(1,3,5,7)]
> IsoMultiSize.norep=MedianNorm(IsoMultiMat.norep)
> NgList.Multi=GetNg(IsoNames.Multi, IsosGeneNames.Multi)
> IsoNgTrun.Multi=NgList.Multi$IsoformNgTrun
> Conditions=c("C1","C2","C3","C4")
> #PosParti.4Cond=GetPatterns(Conditions)
> #PosParti.4Cond
> #Parti.4Cond=PosParti.4Cond[c(1,2,3,8,15),]
> #Parti.4Cond
> IsoMultiOut.norep=EBMultiTest(IsoMultiMat.norep,
+ NgVector=IsoNgTrun.Multi,Conditions=Conditions,
+ sizeFactors=IsoMultiSize.norep, uc = 3)
\end{Sinput}
\begin{Soutput}
Initial number of DE patterns = 14
Final number of DE patterns = 14
\end{Soutput}
\begin{Sinput}
> IsoMultiPP.norep=GetMultiPP(IsoMultiOut.norep)
> IsoMultiFC.norep=GetMultiFC(IsoMultiOut.norep)
\end{Sinput}
\end{Schunk}

\section{EBSeq pipelines and extensions}
\subsection{RSEM-EBSeq pipeline: from raw reads to differential expression analysis results}
EBSeq is coupled with RSEM \cite{Li11b} as an RSEM-EBSeq pipeline which provides 
quantification and DE testing on both gene and isoform levels.

For more details, see 
\url{http://deweylab.biostat.wisc.edu/rsem/README.html#de}

\subsection{EBSeq interface: A user-friendly graphical interface for differetial expression analysis}
EBSeq interface provides a graphical interface implementation for users who are not familiar with the R 
programming language. It takes .xls, .xlsx and .csv files as input. 
Additional packages need be downloaded; they may be found at
\url{http://www.biostat.wisc.edu/~ningleng/EBSeq_Package/EBSeq_Interface/}

\subsection{EBSeq Galaxy tool shed}
EBSeq tool shed contains EBSeq wrappers for a local Galaxy implementation.
For more details, see
\url{http://www.biostat.wisc.edu/~ningleng/EBSeq_Package/EBSeq_Galaxy_toolshed/}

\section{Acknowledgment}
We would like to thank Haolin Xu for checking the package and
proofreading the vignette.

\section{News}
2014-1-30: In EBSeq 1.3.3, the default setting of EBTest function will remove
low expressed genes (genes whose 75th quantile of normalized counts is less
than 10) before identifying DE genes.
These two thresholds can be changed in EBTest function.
Because low expressed genes are disproportionately noisy, 
removing these genes prior to downstream analyses can improve model fitting and increase robustness
(e.g. by removing outliers).

2014-5-22: In EBSeq 1.5.2, numerical approximations are implemented to deal with
underflow. The underflow is likely due to large number of samples.

2015-1-29: In EBSeq 1.7.1, EBSeq incorporates a new function
GetDEResults() which may be used to obtain a list of transcripts under a target FDR in a two-condition experiment.
The results obtained by applying this function with its default setting will be
more robust to transcripts with low variance and potential outliers.
By using the default settings in this function,
the number of genes identified in any given analysis may
differ slightly from the previous version (1.7.0 or order). 
To obtain results that are comparable
to results from earlier versions of EBSeq (1.7.0 or older), a user may set
Method="classic" in GetDEResults() function, or use the original GetPPMat() function.
The GeneDEResults() function also allows a user to modify thresholds to
target genes/isoforms with a pre-specified posterior fold change.

Also, in EBSeq 1.7.1, the default settings in EBTest() and EBMultiTest() function
will only remove transcripts with all 0's (instead of removing transcripts with 
75th quantile less than 10 in version 1.3.3-1.7.0).
To obtain a list of transcripts comparable to the results generated by     EBSeq version 1.3.3-1.7.0, a user may change Qtrm = 0.75 and QtrmCut = 10
when applying EBTest() or EBMultiTest() function.

In EBSeq 1.9.1 Added Q$\&$A seqction in vignette to address common questions

In EBSeq 1.9.2 Fixed a bug which may cause error when input a matrix to the sizeFactors parameter

In EBSeq 1.9.3 Correct typos in GetDEResults help file.

Include an alternative method for normalization. The alternative method is similar to median-by-ratio normalization, 
    	but can deal with the cases when all of the genes/isoforms have at least one zero counts (in which case the 
    	median-by-ratio normalization will fail). This alternative method is developed for single-cell RNA-seq analysis
    	where the dataset always contains a large amount of zeros.
    	
In EBSeq 1.11.1 Fixed a bug in EBTest() which may cause error when performing isoform DE testing 1 sample vs. multiple samples.


In EBSeq 1.28.0 available on Bioconductor: https://bioconductor.org/packages/release/bioc/html/EBSeq.html

In EBSeq 2.0.0 A new implementation of the core functions EBTest and EBMultiTest, which scales up the computation for big number of conditions to compare. 

\section{Common Q and A}
\subsection{Read in data}

csv file:

\verb+In=read.csv("FileName", stringsAsFactors=F, row.names=1, header=T)+

\verb+Data=data.matrix(In)+

\noindent txt file:

\verb+In=read.table("FileName", stringsAsFactors=F, row.names=1, header=T)+

\verb+Data=data.matrix(In)+

\noindent Check \verb+str(Data)+ and make sure it is a matrix instead of data frame. You may need to play around with the \verb+row.names+ 
and \verb+header+ option depends on how the input file was generated.



\subsection{GetDEResults() function not found}

You may on an earlier version of EBSeq. The GetDEResults function
was introduced since version 1.7.1.
The latest release version could be found at:

\url{http://www.bioconductor.org/packages/release/bioc/html/EBSeq.html}

\noindent The latest devel version:

\url{http://www.bioconductor.org/packages/devel/bioc/html/EBSeq.html}

\noindent And you may check your package version by typing \verb+packageVersion("EBSeq")+.


\subsection{Visualizing DE genes/isoforms}

To generate a heatmap, you may consider the heatmap.2 function in gplots package.
For example, you may run

\verb+heatmap.2(NormalizedMatrix[GenesOfInterest,], scale="row", trace="none", Colv=F)+

The normalized matrix may be obtained from \verb+GetNormalizedMat()+ function.


\subsection{My favorite gene/isoform has NA in PP (status "NoTest")}

\indent The NoTest status comes from two sources:

1) In version 1.3.3-1.7.0, using the default parameter settings of EBMultiTest(), the function
will not test on genes with more than 75\% values $\le$ 10 to ensure better
model fitting. To disable this filter, you may set Qtrm=1 and
QtrmCut=0.

2) numerical over/underflow in R. That happens when the within
condition variance is extremely large or small. we did implemented a numerical
approximation step to calculate the approximated PP for these genes
with over/underflow. Here we use $10^{-10}$ to approximate the parameter p
in the NB distribution for these genes (we set it to a small value
since we want to cover more over/underflow genes with low
within-condition variation). You may try to tune this value (to a larger value) in the
approximation by setting \verb+ApproxVal+ in \verb+EBTest()+ or \verb+EBMultiTest()+ function. 

\pagebreak
\bibliographystyle{plain}
\bibliography{lengetal}

\end{document}

